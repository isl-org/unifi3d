"""Script for creating plots of the unconditional metrics on the ground truth data"""

import sys
import yaml
import json
import os
from typing import Any, Optional, List
from pathlib import Path
import numpy as np
import omegaconf
from omegaconf import OmegaConf, DictConfig, ListConfig
from collections import defaultdict, OrderedDict
import matplotlib
from matplotlib import pyplot as plt


def fail_on_missing(cfg: Any) -> None:
    if isinstance(cfg, ListConfig):
        for x in cfg:
            fail_on_missing(x)
    elif isinstance(cfg, DictConfig):
        for _, v in cfg.items():
            fail_on_missing(v)


def parse_args():
    config_str = """
        # Input directory with the json files generated by measure_gt_uncond_metric.py
        input_dir: ???

        # Output directory for the plots
        output_dir: ???
        """
    config = OmegaConf.create(config_str)
    if len(sys.argv) == 1 or "--help" in sys.argv or "-h" in sys.argv:
        print(__doc__)
        print("Default config:\n", config_str)
        sys.exit(1)

    config = OmegaConf.merge(config, OmegaConf.from_cli())
    try:
        fail_on_missing(config)
    except omegaconf.errors.MissingMandatoryValue as exception:
        print(exception)
        sys.exit(1)

    return config


def boxplot_values(data):
    data = np.asarray(data)
    q1 = np.percentile(data, 25)
    q3 = np.percentile(data, 75)
    iqr = q3 - q1
    result = [
        ("median", np.median(data)),
        ("q1", q1),
        ("q3", q3),
        ("iqr", iqr),
        ("whisker_upper", data[data <= q3 + 1.5 * iqr].max()),
        ("whisker_lower", data[data >= q1 - 1.5 * iqr].min()),
    ]
    return dict([(k, float(v)) for k, v in result])


def main():
    cfg = parse_args()
    input_dir = Path(cfg.input_dir)
    output_dir = Path(cfg.output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    json_files = sorted(list(input_dir.glob("*json")))

    data = []
    for x in json_files:
        with open(x, "r") as f:
            data.append(json.load(f))

    data_structured = defaultdict(
        lambda: defaultdict(lambda: defaultdict(lambda: defaultdict(list)))
    )
    for x in data:
        for metric in ("COV", "MMD", "1-NNA"):
            data_structured[x["dataset_name"]][x["category"]][x["set_size"]][
                metric
            ].append(x[metric])

    for ds_name, data_ds in data_structured.items():
        for cat, data_cat in data_ds.items():
            set_sizes = sorted(list(data_cat.keys()))
            for metric in ("COV", "MMD", "1-NNA"):
                vectors = [2 * np.array(data_cat[k][metric]) for k in set_sizes]

                matplotlib.rcParams.update({"font.size": 16})
                plt.clf()
                plt.title(metric)
                plt.ylabel(
                    {
                        "COV": "",
                        "MMD": "Chamfer Distance",
                        "1-NNA": "",
                    }[metric]
                )
                plt.xlabel("$|S_r|, |S_g|$")
                plt.boxplot(vectors, tick_labels=set_sizes)
                filename = f"{ds_name}_{cat}_{metric}_plot.pdf"
                plt.savefig(output_dir / filename, bbox_inches="tight")
                plt.savefig(
                    (output_dir / filename).with_suffix(".png"),
                    bbox_inches="tight",
                    dpi=300,
                )
                bp_values = {
                    set_size: boxplot_values(arr)
                    for set_size, arr in zip(set_sizes, vectors)
                }
                with open((output_dir / filename).with_suffix(".yaml"), "w") as f:
                    yaml.safe_dump(bp_values, f)


if __name__ == "__main__":
    main()
